use libp2p::{
    identity,
    mdns::{self, tokio::Behaviour},
    swarm::{Swarm, SwarmEvent},
    PeerId,
};
use std::error::Error;
use tokio::time::{self, Duration};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

/// Network behavior: currently only mDNS for local discovery.
#[derive(libp2p::swarm::NetworkBehaviour)]
#[behaviour(to_swarm = "MyEvent")]
struct MyBehaviour {
    mdns: Behaviour,
}

/// Events that will be generated by our network behavior
#[derive(Debug)]
enum MyEvent {
    Mdns(mdns::Event),
}

impl From<mdns::Event> for MyEvent {
    fn from(event: mdns::Event) -> Self {
        MyEvent::Mdns(event)
    }
}

/// Represents the current status of a peer in the network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PeerStatus {
    Discovered,
    Connected,
    Disconnected,
}

/// Represents a peer in the network with its metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Peer {
    pub id: String,
    pub status: PeerStatus,
    pub last_seen: String,
}

/// Represents the overall status of the P2P network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkStatus {
    pub total_peers: usize,
    pub connected_peers: usize,
    pub discovered_peers: usize,
    pub peers: Vec<Peer>,
    pub local_peer_id: String,
}

/// Events that can be emitted by the P2P network
#[derive(Debug, Clone)]
pub enum P2PEvent {
    PeerConnected { peer_id: String },
    PeerDisconnected { peer_id: String },
    StatusUpdate { status_text: String },
    PeerCount { count: usize },
    NetworkStatusUpdate { status: NetworkStatus },
}

/// Real P2P node implementation using libp2p
pub struct RealP2PNode {
    swarm: Swarm<MyBehaviour>,
    pub event_sender: mpsc::UnboundedSender<P2PEvent>,
    is_running: bool,
    peers: Vec<Peer>,
    local_peer_id: String,
}

impl RealP2PNode {
    /// Creates a new P2P node with a unique cryptographic identity
    /// 
    /// Returns a tuple containing the node and an event receiver for network events.
    /// 
    /// # Errors
    /// 
    /// Returns an error if:
    /// - Failed to generate cryptographic keys
    /// - Failed to create transport layer
    /// - Failed to initialize mDNS behavior
    /// - Failed to bind to network address
    pub async fn new() -> Result<(Self, mpsc::UnboundedReceiver<P2PEvent>), Box<dyn Error>> {
        // Create unique cryptographic identity for our node
        let local_key = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());
        log::info!("Created P2P node with peer ID: {}", local_peer_id);

        // Create transport layer (TCP)
        let transport = libp2p::tokio_development_transport(local_key)?;

        // Create our network behavior
        let behaviour = MyBehaviour {
            mdns: mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?,
        };

        // Create Swarm - this is our node
        let mut swarm = Swarm::new(transport, behaviour, local_peer_id);

        // Tell Swarm to listen for incoming connections
        swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

        let (event_sender, event_receiver) = mpsc::unbounded_channel();

        Ok((RealP2PNode {
            swarm,
            event_sender,
            is_running: false,
            peers: Vec::new(),
            local_peer_id: local_peer_id.to_string(),
        }, event_receiver))
    }

    /// Starts the P2P node and begins listening for network events
    /// 
    /// # Errors
    /// 
    /// Returns an error if:
    /// - Failed to send initial status update
    /// - Failed to send network status update
    pub async fn start(&mut self) -> Result<(), Box<dyn Error>> {
        self.is_running = true;
        
        log::info!("P2P node started. Local ID: {}", self.local_peer_id);
        self.event_sender.send(P2PEvent::StatusUpdate {
            status_text: format!("Network started. Your ID: {}", self.local_peer_id),
        }).map_err(|e| format!("Failed to send status update: {}", e))?;

        // Send initial network status
        self.send_network_status_update().await?;

        Ok(())
    }

    /// Sends current network status to all subscribers
    /// 
    /// # Errors
    /// 
    /// Returns an error if failed to send network status update
    async fn send_network_status_update(&mut self) -> Result<(), Box<dyn Error>> {
        let connected_count = self.peers.iter().filter(|p| matches!(p.status, PeerStatus::Connected)).count();
        let discovered_count = self.peers.iter().filter(|p| matches!(p.status, PeerStatus::Discovered)).count();
        
        let status = NetworkStatus {
            total_peers: self.peers.len(),
            connected_peers: connected_count,
            discovered_peers: discovered_count,
            peers: self.peers.clone(),
            local_peer_id: self.local_peer_id.clone(),
        };

        self.event_sender.send(P2PEvent::NetworkStatusUpdate { status })
            .map_err(|e| format!("Failed to send network status update: {}", e))?;
        Ok(())
    }

    /// Adds or updates a peer in the network with the given status
    /// 
    /// # Arguments
    /// 
    /// * `peer_id` - The unique identifier of the peer
    /// * `status` - The current status of the peer
    /// 
    /// # Errors
    /// 
    /// Returns an error if failed to send network status update
    async fn add_or_update_peer(&mut self, peer_id: String, status: PeerStatus) -> Result<(), Box<dyn Error>> {
        let now = chrono::Utc::now().format("%H:%M:%S").to_string();
        
        if let Some(peer) = self.peers.iter_mut().find(|p| p.id == peer_id) {
            peer.status = status;
            peer.last_seen = now;
        } else {
            self.peers.push(Peer {
                id: peer_id,
                status,
                last_seen: now,
            });
        }

        self.send_network_status_update().await?;
        Ok(())
    }

    /// Main event loop that processes network events
    /// 
    /// This function runs indefinitely while the node is running and processes
    /// all network events including peer discovery, disconnection, and new connections.
    /// 
    /// # Errors
    /// 
    /// Returns an error if:
    /// - Failed to process network events
    /// - Failed to send status updates
    /// - Network transport errors
    pub async fn run_event_loop(&mut self) -> Result<(), Box<dyn Error>> {
        while self.is_running {
            // Poll Swarm for new events
            match self.swarm.select_next_some().await {
                SwarmEvent::Behaviour(MyEvent::Mdns(mdns::Event::Discovered(list))) => {
                    for (peer_id, _multiaddr) in list {
                        log::info!("mDNS discovered a new peer: {}", peer_id);
                        
                        // Add peer to our list
                        self.add_or_update_peer(peer_id.to_string(), PeerStatus::Discovered).await?;
                        
                        self.event_sender.send(P2PEvent::StatusUpdate {
                            status_text: format!("Discovered new participant: {}", peer_id),
                        }).map_err(|e| format!("Failed to send status update: {}", e))?;
                    }
                }
                SwarmEvent::Behaviour(MyEvent::Mdns(mdns::Event::Expired(list))) => {
                    for (peer_id, _multiaddr) in list {
                        log::info!("mDNS peer has expired: {}", peer_id);
                        
                        // Mark peer as disconnected
                        self.add_or_update_peer(peer_id.to_string(), PeerStatus::Disconnected).await?;
                        
                        self.event_sender.send(P2PEvent::StatusUpdate {
                            status_text: format!("Participant {} left the network.", peer_id),
                        }).map_err(|e| format!("Failed to send status update: {}", e))?;
                    }
                }
                SwarmEvent::NewListenAddr { address, .. } => {
                    log::info!("Local node is listening on {}", address);
                    self.event_sender.send(P2PEvent::StatusUpdate {
                        status_text: format!("Node listening on address: {}", address),
                    }).map_err(|e| format!("Failed to send status update: {}", e))?;
                }
                _ => {}
            }
        }

        Ok(())
    }

    /// Returns the number of currently connected peers
    /// 
    /// # Returns
    /// 
    /// The number of peers with Connected status
    pub fn get_peer_count(&self) -> usize {
        self.peers.iter().filter(|p| matches!(p.status, PeerStatus::Connected)).count()
    }
}

// For backward compatibility
pub type P2PNode = RealP2PNode;

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_p2p_node_creation() {
        let result = RealP2PNode::new().await;
        assert!(result.is_ok(), "Failed to create P2P node: {:?}", result.err());
        
        let (node, _receiver) = result.unwrap();
        assert!(!node.local_peer_id.is_empty(), "Local peer ID should not be empty");
        println!("Test passed: Created P2P node with ID: {}", node.local_peer_id);
    }

    #[tokio::test]
    async fn test_p2p_node_start() {
        let (mut node, _receiver) = RealP2PNode::new().await.unwrap();
        let result = node.start().await;
        assert!(result.is_ok(), "Failed to start P2P node: {:?}", result.err());
        println!("Test passed: P2P node started successfully");
    }
} 